<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Modality Gap Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background-color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 320px;
            border: 1px solid #e0e0e0;
            pointer-events: auto;
            /* Ensure clicks work */
        }

        h1 {
            font-size: 18px;
            margin: 0 0 10px 0;
            color: #333;
        }

        p {
            font-size: 13px;
            color: #666;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        #btn-ideal {
            background: #e0f2f1;
            color: #00695c;
        }

        #btn-gap {
            background: #ffebee;
            color: #c62828;
            border: 2px solid #c62828;
        }

        button:hover {
            transform: translateY(-1px);
            filter: brightness(0.95);
        }

        button.active {
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 12px;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .dot.blue {
            background: #2196F3;
            box-shadow: 0 0 5px #2196F3;
        }

        .dot.red {
            background: #F44336;
            box-shadow: 0 0 5px #F44336;
        }

        .dot.yellow {
            background: #FFC107;
            height: 2px;
            width: 15px;
            border-radius: 0;
        }

        #metrics {
            margin-top: 15px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
        }

        /* Tooltip Styles */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
            transform: translate(15px, 15px);
            white-space: nowrap;
        }

        #tooltip img {
            margin-top: 8px;
            border-radius: 4px;
            max-width: 150px;
            display: block;
        }

        #tooltip .tooltip-text {
            margin-top: 4px;
            font-size: 11px;
            color: #ccc;
            max-width: 150px;
            white-space: normal;
        }

        /* Preview Panel Styles */
        #preview-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            width: 600px;
            display: none;
            /* Hidden by default */
            display: flex;
            /* Flex when shown (overridden by JS) */
            gap: 20px;
            border: 1px solid #e0e0e0;
            z-index: 200;
        }

        .preview-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .preview-col h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .preview-img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .preview-text {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            height: 170px;
            /* Match approx image height */
            overflow-y: auto;
            width: 100%;
            box-sizing: border-box;
            border: 1px solid #eee;
        }

        #close-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #999;
            padding: 5px;
        }

        #close-preview:hover {
            color: #333;
        }
    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>

    <div id="tooltip"></div>

    <div id="preview-panel" style="display: none;">
        <button id="close-preview" onclick="deselectPair()">Ã—</button>

        <div class="preview-col">
            <h3>Image Representation</h3>
            <img id="preview-img-el" class="preview-img" src="" alt="Preview">
        </div>

        <div class="preview-col">
            <h3>Text Representation</h3>
            <div id="preview-text-el" class="preview-text"></div>
        </div>
    </div>

    <div id="ui-panel">
        <h1>Modality Gap Visualizer</h1>
        <p>1000 Pairs (2000 points) inside a volumetric sphere. Ideal mode shows 100 distinct semantic groups.</p>

        <div class="controls">
            <button id="btn-ideal" onclick="setMode('ideal')">Ideal (Mixed)</button>
            <button id="btn-gap" onclick="setMode('gap')">Reality (Gap)</button>
        </div>

        <div id="metrics">
            Status: <span id="status-text">Separated (The Gap)</span><br>
            Avg Distance: <span id="dist-score">High</span>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="dot blue"></div> Text Embeddings
            </div>
            <div class="legend-item">
                <div class="dot red"></div> Image Embeddings
            </div>
            <div class="legend-item">
                <div class="dot yellow"></div> The Gap (Connection)
            </div>
            <div style="font-size: 11px; color: #888; margin-top:5px;">
                * Hover to highlight specific pairs.<br>
                * Lines are faint to reduce clutter.
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // Setup Scene
        const container = document.getElementById('canvas-container');
        const tooltip = document.getElementById('tooltip');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); // White background
        scene.fog = new THREE.Fog(0xffffff, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 14, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 0.2; // Hit test tolerance
        const mouse = new THREE.Vector2();
        let intersectedObject = null;
        let selectedPairId = null;
        let lastHighlightedId = null;

        // Data Storage
        const bluePoints = [];
        const redPoints = [];
        const gapLines = []; // Lines connecting corresponding Blue and Red
        const interactables = []; // Array for raycaster

        // Configuration
        const numPoints = 1000;
        const numGroups = 100; // New: 100 groups requested
        const pairsPerGroup = numPoints / numGroups; // 10 pairs per group
        const maxRadius = 10;

        // Geometries & Materials
        // Reduced segments for performance with 1000 points
        const sphereGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const blueMat = new THREE.MeshPhongMaterial({ color: 0x2196F3, shininess: 50 });
        const redMat = new THREE.MeshPhongMaterial({ color: 0xF44336, shininess: 50 });

        // Line Material - Fainter because there are 1000 of them
        const lineMatGap = new THREE.LineBasicMaterial({ color: 0xFFC107, transparent: true, opacity: 0.15 });

        // Initialize Points
        function initPoints() {
            for (let i = 0; i < numPoints; i++) {
                // Create Text Dot (Blue)
                const blueDot = new THREE.Mesh(sphereGeo, blueMat.clone());
                blueDot.userData = { id: i, type: 'Text', label: `Data Pair #${i + 1}`, group: Math.floor(i / pairsPerGroup) + 1 };
                bluePoints.push({ mesh: blueDot, targetPos: new THREE.Vector3() });
                scene.add(blueDot);
                interactables.push(blueDot);

                // Create Image Dot (Red)
                const redDot = new THREE.Mesh(sphereGeo, redMat.clone());
                redDot.userData = { id: i, type: 'Image', label: `Data Pair #${i + 1}`, group: Math.floor(i / pairsPerGroup) + 1 };
                redPoints.push({ mesh: redDot, targetPos: new THREE.Vector3() });
                scene.add(redDot);
                interactables.push(redDot);

                // Create Connection Line (The Gap)
                const gGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
                const gLine = new THREE.Line(gGeo, lineMatGap.clone()); // Clone to allow individual highlighting
                gapLines.push(gLine);
                scene.add(gLine);
            }
        }

        // Spherical coordinate helper (Volume)
        function getVolumetricPoint(maxR, theta, phi) {
            // Cube root of random number for uniform volumetric distribution
            const r = maxR * Math.cbrt(Math.random());
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        // Helper to get point in specific cone direction
        function getConePoint(maxR, coneDirection, spreadAngle) {
            const r = maxR * Math.cbrt(Math.random());

            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(1 - (1 - Math.cos(spreadAngle)) * v);

            // Point around Z axis
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            const point = new THREE.Vector3(x, y, z);

            // Rotate to match coneDirection
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), coneDirection.clone().normalize());
            point.applyQuaternion(quaternion);

            return point;
        }


        let currentMode = 'gap';

        function calculatePositions(mode) {
            currentMode = mode;
            const statusText = document.getElementById('status-text');
            const distScore = document.getElementById('dist-score');
            const btnGap = document.getElementById('btn-gap');
            const btnIdeal = document.getElementById('btn-ideal');

            if (mode === 'ideal') {
                statusText.innerText = "Intermingled (100 Semantic Groups)";
                statusText.style.color = "#00695c";
                distScore.innerText = "Near Zero (Connected)";
                btnIdeal.style.border = "2px solid #00695c";
                btnGap.style.border = "none";
                controls.autoRotateSpeed = 0.2;

                // Grouping logic for 100 groups * 10 pairs/group
                for (let g = 0; g < numGroups; g++) {
                    // 1. Pick a single random central location for this group
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const groupCenter = getVolumetricPoint(maxRadius, theta, phi);

                    for (let p = 0; p < pairsPerGroup; p++) {
                        const i = g * pairsPerGroup + p; // Global index of the data pair

                        // 2. Add slight local noise around the group center (tight cluster radius: 0.5)
                        const localNoise = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 * Math.random());
                        const basePos = groupCenter.clone().add(localNoise);

                        // 3. Text (Blue) is at basePos
                        bluePoints[i].targetPos = basePos.clone();

                        // 4. Image (Red) is very close to Blue (minimal noise for proximity: 0.1)
                        const pairNoise = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.1 * Math.random());
                        redPoints[i].targetPos = basePos.clone().add(pairNoise);
                    }
                }

            } else {
                statusText.innerText = "Separated (Modality Gap)";
                statusText.style.color = "#c62828";
                distScore.innerText = "Large (Arm's Length)";
                btnGap.style.border = "2px solid #c62828";
                btnIdeal.style.border = "none";
                controls.autoRotateSpeed = 0.5;

                // Define Cone Directions (Separation by Modality)
                const blueDir = new THREE.Vector3(-1, 0, 0);
                const redDir = new THREE.Vector3(1, 0, 0);

                // Cluster Blue
                for (let i = 0; i < numPoints; i++) {
                    bluePoints[i].targetPos = getConePoint(maxRadius, blueDir, Math.PI / 2.5);
                }

                // Cluster Red
                for (let i = 0; i < numPoints; i++) {
                    redPoints[i].targetPos = getConePoint(maxRadius, redDir, Math.PI / 2.5);
                }
            }
        }

        // Raycasting Logic
        function onMouseMove(event) {
            // Normalize mouse coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Move tooltip
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
        }

        window.addEventListener('mousemove', onMouseMove, false);

        // Helper for Semantic Data
        function getSemanticData(id) {
            const categories = ['cat', 'dog', 'city', 'nature', 'food', 'transport', 'business', 'nightlife', 'sports', 'fashion'];
            const keyword = categories[id % categories.length];
            return {
                keyword: keyword,
                imgUrl: `https://loremflickr.com/400/300/${keyword}?lock=${id}`,
                text: `A detailed textual description of <strong>${keyword}</strong>. This embedding represents the semantic concept of ${keyword} found in the dataset. It captures the nuances of the visual representation in a high-dimensional vector space.`
            };
        }

        // Click Handler
        window.addEventListener('click', (event) => {
            // Ignore clicks on UI
            if (event.target.closest('#ui-panel') || event.target.closest('#preview-panel')) return;

            // If we are hovering over an object, select it
            if (intersectedObject) {
                const data = intersectedObject.userData;
                selectPair(data.id);
            } else {
                // Clicked on empty space - Deselect
                deselectPair();
            }
        });

        function selectPair(id) {
            selectedPairId = id;
            controls.autoRotate = false;

            // Focus camera
            const bluePos = bluePoints[id].mesh.position;
            const redPos = redPoints[id].mesh.position;
            const midpoint = new THREE.Vector3().addVectors(bluePos, redPos).multiplyScalar(0.5);
            controls.target.copy(midpoint);

            // Show Preview Panel
            const panel = document.getElementById('preview-panel');
            const imgEl = document.getElementById('preview-img-el');
            const textEl = document.getElementById('preview-text-el');

            const semantic = getSemanticData(id);

            imgEl.src = semantic.imgUrl;
            textEl.innerHTML = semantic.text;

            panel.style.display = 'flex';
        }

        function deselectPair() {
            selectedPairId = null;
            controls.autoRotate = true;
            controls.target.set(0, 0, 0); // Reset to center
            document.getElementById('preview-panel').style.display = 'none';
        }

        // Expose globally for close button
        window.deselectPair = deselectPair;

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Lerp points to target positions
            const lerpSpeed = 0.05;

            for (let i = 0; i < numPoints; i++) {
                // Move Blue
                bluePoints[i].mesh.position.lerp(bluePoints[i].targetPos, lerpSpeed);
                // Move Red
                redPoints[i].mesh.position.lerp(redPoints[i].targetPos, lerpSpeed);

                // Update Connection Line
                const gPositions = gapLines[i].geometry.attributes.position.array;

                gPositions[0] = bluePoints[i].mesh.position.x;
                gPositions[1] = bluePoints[i].mesh.position.y;
                gPositions[2] = bluePoints[i].mesh.position.z;

                gPositions[3] = redPoints[i].mesh.position.x;
                gPositions[4] = redPoints[i].mesh.position.y;
                gPositions[5] = redPoints[i].mesh.position.z;

                gapLines[i].geometry.attributes.position.needsUpdate = true;
            }

            // Raycasting logic
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables);

            // Handle Hover & Selection Visuals
            let targetId = selectedPairId;
            let isHovering = false;

            if (intersects.length > 0) {
                const obj = intersects[0].object;

                // Only update if the intersected object has changed
                if (obj !== intersectedObject) {
                    intersectedObject = obj;

                    // Show Tooltip & Update Content
                    tooltip.style.display = 'block';
                    const data = intersectedObject.userData;

                    // Semantic Data Generation
                    // Re-use helper logic for consistency, but keep small for tooltip
                    const categories = ['cat', 'dog', 'city', 'nature', 'food', 'transport', 'business', 'nightlife', 'sports', 'fashion'];
                    const keyword = categories[data.id % categories.length];
                    const imgUrl = `https://loremflickr.com/200/150/${keyword}?lock=${data.id}`;

                    let specificContent = '';
                    if (data.type === 'Image') {
                        specificContent = `<img src="${imgUrl}" alt="${keyword}">`;
                    } else {
                        specificContent = `
                        <div class="tooltip-text">
                            "A detailed textual description of <strong>${keyword}</strong>. This embedding represents the semantic concept of ${keyword} found in the dataset."
                        </div>`;
                    }

                    tooltip.innerHTML = `
                        <strong>${data.label}</strong> (Group ${data.group})<br>
                        <span style="color:#aaa; font-size:10px;">${data.type} Embedding</span>
                        ${specificContent}
                    `;
                }

                isHovering = true;

                // If nothing is selected, highlight the hovered one
                if (selectedPairId === null) {
                    targetId = intersectedObject.userData.id;
                }
            } else {
                if (intersectedObject) {
                    intersectedObject = null;
                    tooltip.style.display = 'none';
                }
            }

            // Apply Highlights
            if (lastHighlightedId !== null && lastHighlightedId !== targetId) {
                const oldId = lastHighlightedId;
                // Reset Blue
                bluePoints[oldId].mesh.material.emissive.setHex(0x000000);
                // Reset Red
                redPoints[oldId].mesh.material.emissive.setHex(0x000000);
                // Reset Line
                gapLines[oldId].material.opacity = 0.15;
                gapLines[oldId].material.color.setHex(0xFFC107);
                gapLines[oldId].material.linewidth = 1;
            }

            if (targetId !== null) {
                // Highlight current target (Selected or Hovered)
                bluePoints[targetId].mesh.material.emissive.setHex(0x555555);
                redPoints[targetId].mesh.material.emissive.setHex(0x555555);

                gapLines[targetId].material.opacity = 1.0;
                gapLines[targetId].material.color.setHex(0xFF0000);

                lastHighlightedId = targetId;
            } else {
                lastHighlightedId = null;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Global function for buttons
        window.setMode = calculatePositions;

        // Init
        initPoints();
        calculatePositions('gap'); // Start with the Reality/Gap
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>